### 堆栈的区别

- 堆： heap是动态分配的内存，大小不定也不会自动释放，空间超大，访问随机灵活。缺点是访问慢，修改慢，释放慢，整理慢，或者说垃圾回收慢。

- 栈: stack为自动分配的内存空间，它由系统自动释放，生命周期短，一般只在一个功能内存活。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。

- 队列： 而队列数据结构的访问规则是FIFO(Fist-In-First-Out,先进先出)。队列在列表的末端添加项，从列表的前端移除项。

- 5中基本数据类型： 存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配
    Undefined、Null、Boolean、Number 和 String

- 1种引用数据类型： 存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。对象、数组、函数

- js中数组模拟的堆栈和操作注意事项
unshift()比push()要慢差不多100倍!
因此，平时还是要慎用unshift()，特别是对大数组。
那如果一定要达到unshift()的效果，可以借助于Array的reverse()方法
Array的reverse()的方法能够把一个数组反转。
先把要放进数组的元素用push()添加，再执行一次reverse()，就达到了unshift()的效果。

[全面的数组操作方法](https://cfangxu-2.gitbook.io/front-end-basics/javascript/shu-ju-jie-gou-he-suan-fa/array)

#### 创建数组的方法

```javascript
// 1. 空数组
var arr = [];

// 2. 可放入不同的类型
var arr = [1, 'a'];

// 3. 数组的元素可以是表达式
var num = 1;
var arr = [num. num + 1, num + 2];

// 4. 空数组只有逗号，里面的元素打印出来是undefied
var arr = [,,];

// 5. 构造函数创建数组, 1个参数是长度，1个以上参数是数组的具体元素
var arr = new Array(10);

// 6. ES6的Array.of()方法，参数是组成的数组的具体元素
var arr = Array.of(1,2,3); // [1, 2, 3]

// 7. ES6的Array.from()方法,从一个类数组或者可迭代对象中创建一个数组
/**
* 第一个参数：想要转换成数组的类数组或可迭代对象
* 第二个参数（可选）：回调函数，类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。
* 第三个参数（可选）：绑定回调函数的this对象
*/
Array.from({length：5},(v,i) => i)     //[0, 1, 2, 3, 4]

// 部署了Iterator接口的数据结构 比如:字符串、Set、NodeList对象
Array.from('hello')    // ['h','e','l','l','o']
Array.from(new Set(['a','b']))   // ['a','b']

// 传入一个数组生成的是一个新的数组，引用不同，修改新数组不会改变原数组
let arr1 = [1,2,3]
let arr2 = Array.from(arr1);

```

### 下面列举了数组的30个方法

#### 1. 会改变自身的方法

- push 末尾增加元素，返回新数组长度

- pop 末尾删除，返回被删除的元素

- shift 开头删除，返回被删除的元素

- unshift 开头添加，返回数组的长度

- reverse 数组翻转，返回被翻转的数组

- sort  数组排序，返回被排序的数组，可以有复杂的参数判断

- fill 指定区间元素替换为某个值

- copyWithin 一段原数组的序列被替换为另一个序列，三个参数target start end

- splice(index,howmany,item1,.....,itemX)(拼接合并的意思) 修改元素----删除、替换原地添加新的元素， 返回被删除的元素

#### 2. 不会改变自身的方法

- includes 判断方法--数组是否包含指定值

- concat 两个或者多个数组合并，返回新数组,多个时concat参数传入多个数组即可

- join 数组或者数组对象的元素被拼接成一个字符串并返回字符串

- slice(a,b)(切片的意思) 截取一段数组，从a位置到b位置，浅拷贝数组(引用类型是引用地址)。返回从a到b的新数组

- toString 返回一个字符串，表示指定的数组及其元素。

- toLocaleString 返回一个字符串表示数组中的元素。参数比较复杂，可配置性高

- indexOf 返回在数组中可以找到一个给定元素的第一个索引

- lastIndexOf 返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引

#### 3. 遍历方法

- map 遍历数组每一个元素，必须有返回值

- forEach 遍历数组每一个元素，没有返回值

- filter 通过函数表达式过滤数据

- reduce  用指定的函数将数组元素进行组合，生成单个值,从左到右

- reduceRight 用指定的函数将数组元素进行组合，生成单个值，从右到左

- some 至少有一个符合某个函数表达式，返回true/false

- every 每一项都符合某个函数表达式，返回true/false

- find 查找符合函数表达式的这一项，并返回这一项

- findIndex 查找符合函数表达式的这一项，并返回索引

- keys (一种迭代器)返回一个包含数组中每个索引键的Array Iterator对象。

- entries (一种迭代器)返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。iterator1.next().value

- values (一种迭代器)返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值

#### ES10新增

- flat 树形结构数组变为平铺结构。按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回


#### 生成固定长度不重复随机数的数组

1. 生成2~32之间不重复随机数的数组，数组长度是5，不能用for/while等循环

> 先创建长度为5的空数组方法,用includes方法来判断是否已有，用index控制递归次数
```javascript
var arr = new Array(5);
var index = 0;
function pushArr(min, max) {
    // floor 向下取整 Math.floor(11.46)=Math.floor(11.68)=Math.floor(11.5)=11
    var rand = Math.floor(Math.random() * (max - min + 1)) + min;
    if (!arr.includes(rand) && index < arr.length) {
        arr[index] = rand;
        index++;
        pushArr(min, max)
    }
    if (arr.includes(rand) && index < arr.length) {
        pushArr(min, max)
    }
}
pushArr(2, 32);
console.log(arr, 'arr
```
2. 生成2~32之间不重复随机数的数组，数组长度是5，不能用for/while等循环

> 先创建长度为0的空数组方法，用new Set方法为数组去重，用from方法把set结构转为数组，用length控制递归次数
```javascript
var newArr = [];
function pushSetArr(min, max, length) {
   // ceil 向上取整， Math.ceil(11.16)=Math.ceil(11.68)=Math.ceil(11.5)=12
  var rand = Math.ceil(Math.random() * (max - min)) + min;
  if (newArr.length < length) {
      newArr.push(rand);
      newArr = Array.from(new Set(newArr));
      pushSetArr(min, max);
  }
}
pushSetArr(2, 32, 5)
```
