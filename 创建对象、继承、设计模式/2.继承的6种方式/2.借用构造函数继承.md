借用构造函数继承
========

#### 构造函数继承基本思想
在子类型构造函数的内部调用超类型构造函数

为了解决原型中包含引用类型值所带来问题

```javascript
function SuperType(name){
    this.colors = ["red", "blue", "green"];
    this.name = name;
}

function SubType(){

   //继承了 SuperType, "借调”了超类型的构造函数，本质上是用一个智者把SubType指向了SuperType的作用于
   // 从而可以调取SuperType的书序和方法

   SuperType.call(this, 'sam');
}

var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors);    //"red,blue,green,black"
var instance2 = new SubType();
alert(instance2.colors);    //"red,blue,green"

```

- 通过使用 call()方法(或 apply()方法 也可以)，我们实际上是在(未来将要)新创建的 SubType 实例的环境下调用了 SuperType 构造函数。
 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。
 结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。
- 为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。
- 避免了引用类型的属性被所有实例共享
- 可以在子类中向父类传参

缺点：
- 每个实例都拷贝一份父类构造函数中的方法，作为实例自己的方法，占用内存大。
- 后面的实例修改其中的父类方法时，只有后面的实例能访问到新方法，前面的实例无法访问到，因为前面的实例已经执行了。

> ![构造函数实例的原型链](https://github.com/samsonCao/sam_blog/blob/master/Image/prototype_link.png)
- 所有的对象最终都继承于Object.prototype
- 所有的构造函数，包括function Object在内，又都可以看做是function Function的实例。


- __proto__和constructor属性是对象所独有的
- prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
- __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，
一直找，直到__proto__属性的终点null，然后返回undefined，通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
- prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
- constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

https://blog.csdn.net/cc18868876837/article/details/81211729
