原型继承原理
======
将传入的对象作为创建的对象的原型

```javascript
function createObj(o) {

    // 创建了一个临时性的构造函数
    function F(){}

    // 将传入的对象作为这个构造函数的原型
    F.prototype = o;

    // 返回了这个临时类型的一个新实例
    return new F();
}
```
> 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

#### Object.create()简单介绍
```javascript
var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};

// 返回的是新实例，是新的内存空间,跟person没关系
var person1 = Object.create(person);
person1.name = "Greg";
person1.friends.push("Rob");

// 返回的是新实例，是新的内存空间, ,跟person没关系
var person2 = Object.create(person);
person2.name = "Linda";
person2.friends.push("Barbie");

// 实例上的属性修改，并不会相互影响
person.name; // "Nicholas"
person1.name; // "Greg", 修改person1不会影响person
person2.name; // Linda, 修改person2不会影响person

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```

缺点

包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。
