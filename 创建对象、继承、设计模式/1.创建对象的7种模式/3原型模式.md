#### 理解prototype属性
定义：我们创建的每个函数都有一个 prototype(原型)属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
解析
- prototype是每个函数都自带的属性
- prototype是一个指针
- prototype指向一个对象
- prototype指向的对象可以扩展出任意的属性和方法
- 这些属性和方法可以被函数继承，即函数的实例可以调用这些方法

```javascript
// 构造函数Person是空函数
function Person(){

}

//  sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
person1.sayName();   //"Nicholas"

var person2 = new Person();
person2.sayName(); //"Nicholas"

// 新对象的这些属性和方法是由所有实例共享的
alert(person1.sayName == person2.sayName);  //true
```
#### 代码解析
-  构造函数Person是空函数
- sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中
- 仍然可以通过`new`调用构造函数来创建新对象
- 新对象还会具有相同的属性和方法
- 新对象的这些属性和方法是由所有实例共享的,person1 和 person2 访问的都是同一组属性和同一个 sayName()函数

理解原型对象
======
#### 先分析Person函数创建过程
- 创建函数Person
- 自动为Person创建一个prototype属性
- Person内部的堆内存创建一个新的对象----称为`原型对象`
- prototype属性指向这个`原型对象`
- `原型对象`自动获取一个constructor属性---称为`构造函数`属性
- constructor属性有个指针自动指向prototype属性所在的函数，即constructor指向Person
- 从Object继承一些自带的属性和方法比如set get等
就拿前面的例子来说，Person.prototype.constructor 指向 Person。
而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。
#### 再分析Person实例化的过程
- 调用构造函数创建实例
```javascript
var person1 = new Person();
```
- 实例的内部将自动包含一个指针(内部属性)，指向`构造函数的原型对象`。
说明： ECMA-262 第 5 版中管这个指针叫[[Prototype]]，在脚本中 没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 __proto__;而在其他实现中，这个属性对脚本则是完全不可见的
- 这个连接存在于`实例`与`构造函数的原型对象`之间，而不是存在于`实例`与`构造函数`之间
- 请看下方的说明图
![原型模式的原型链指向](https://github.com/samsonCao/sam_blog/blob/master/Image/prototype.png)
