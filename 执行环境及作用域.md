- 执行环境(execution context，为简单起见，有时也称为“环境”)是 JavaScript 中最为重要的一个概 念。
- 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
- 每个执行环境都有一个 与之关联的变量对象(variable object)，`环境中定义的所有变量和函数都保存在这个对象中`。
- 虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
- 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环 境的对象也不一样。
- 在 Web 浏览器中，全局执行环境被认为是 window 对象(第 7 章将详细讨论)，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。
- 某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁)。
- 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个`环境栈`中。
- 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。
- 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。
- 作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。
- 作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。
- 活动对象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。
- 作用域链中 的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。
- 这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。
- 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)
- `每个环境都 可以向上搜索作用域链，以查询变量和函数名;但任何环境都不能通过向下搜索作用域链而进入另一个 执行环境。`
-  函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。
- 执行环境的类型总共只有两种——全局和局部(函数)，但还是有其他办法来延长作用域链。
--------
- 执行环境有全局执行环境(也称为全局环境)和函数执行环境之分
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链;
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全
  局环境;
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;
- 变量的执行环境有助于确定应该何时释放内存。
```javascript
    var color = "blue";
    function changeColor(){
        var anotherColor = "red";
        function swapColors(){
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
// 这里可以访问color、anotherColor和tempColor }
// 这里可以访问color和anotherColor，但不能访问tempColor
        swapColors();
    }
// 这里只能访问color changeColor();

```
以上代码共涉及 3 个执行环境:
- 全局环境
- changeColor()的局部环境
- swapColors()的局部 环境。
全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有 一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变 量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。 无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部 则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。

#### 延长作用域链
虽然执行环境的类型总共只有两种——全局和局部(函数)，但还是有其他办法来延长作用域链。 这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移 除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会 得到加长:

- try-catch 语句的 catch 块;
- with 语句。
这两个语句都会在作用域链的前端添加一个变量对象。
对 with 语句来说，会将指定的对象添加到作用域链中。
对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
下面看一个例子。
```javascript
function buildUrl() {
    var qs = "?debug=true";
    with(location){
        var url = href + qs;
    }
    return url;
}
```
with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量 qs。当在 with 语句中引用变量 href 时(实际引用的是 location.href)，可以在当前执行环境的变量对象中 找到。当引用变量 qs 时，引用的则是在 buildUrl()中定义的那个变量，而该变量位于函数环境的变 量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一 部分，所以可以作为函数的值被返回。

#### 没有块级作用域
JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码 块都有自己的作用域(如果用 ECMAScript 的话来讲，就是它们自己的执行环境)，因而支持根据条件来 定义变量。例如，下面的代码在 JavaScript 中并不会得到想象中的结果:
```javascript
for (var i=0; i < 10; i++){
        doSomething(i);
}
    alert(i);      //10

```
对于有块级作用域的语言来说，for 语句初始化变量的表达式所定义的变量，只会存在于循环的环 境之中。而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在 于循环外部的执行环境中。


使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部 环境;在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。
