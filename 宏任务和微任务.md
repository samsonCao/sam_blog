### 宏任务和微任务区别和由来

- ES6新增的Promise让JS任务新增了一个概念：microtask---微任务
- 因此JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task

- macrotask（又称之为宏任务）
可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
每一个task会从头到尾将这个任务执行完毕，不会执行其它
浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲
    ```
     大致看起来是这个样子的
    （`task->渲染->task->渲染...`）
    ```

- microtask（又称为微任务）
可以理解是在当前 task 执行结束后立即执行的任务
也就是说，在当前task任务后，下一个task之前，在渲染之前
所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲

- 宏任务和微任务场景区分
    - macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）
    - microtask：Promise，准确的说是Promise().then()产生了微任务。process.nextTick等
    - 在node环境下，process.nextTick的优先级高于Promise__，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分

总结下运行机制：

执行一个宏任务（栈中没有就从事件队列中获取）
执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
宏任务执行完毕后，且js执行栈中为空，立即执行当前微任务队列中的所有微任务（依次执行）
当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
 ```
     大致看起来是这个样子的
    （`task->微任务(如果有)->渲染---->task->微任务(如果有)->渲染...`）
 ```

 学完上面的知识，来做一个简单的练习题吧

 ```
 尝试说出下面的输出顺序
 setTimeout(function(){
     console.log('1')
 });

 new Promise(function(resolve){
     console.log('2');
     resolve();
 }).then(function(){
     console.log('3')
 });

 console.log('4');
 ```
 正确答案： 2、4、3、1
 过程解析
- 程序自上而下执行
- setTimeout是宏任务，放入宏任务队列
- Promise中的函数在主线程中，执行，输出2
- Promise的then是微任务，放入微任务队列
- console.log('4')在主线程中，输出4
- 主线程执行完
- 去微任务队列中找有没有任务，找到then执行，输出3
- 继续找微任务队列，没有微任务了，去找宏任务
- 找到宏任务setTimeout执行，输出1
-继续找宏任务，没有宏任务了，程序终止


参考： https://segmentfault.com/a/1190000012925872
