### 理念

代数效应：把副作用从函数调用中剥离出去，使函数组件看起来更纯粹（避免大量传染性的 async await）

### hooks 实现思路

```javascript
// 第一步，定义一个 reducer，派发action
function reducer(state, action) {
  switch(action.type) {
    case "add":
      return { count: state.count + 1};
    default:
      return state;
  }
}

// 定义函数组件
function FnReducer(props) {
  // 第二步，把reducer传入useReducer，并返回当前state和 dispatchCount触发动作更新的函数
  const [count, dispatchCount] = useReducer(reducer, { count: 0 });

  // 可以理解为
  // const [count, dispatchCount] = useReducer( { count: state.count + 1}, { count: 0 });

  return (
    <div>
      <button onClick={() => dispatchCount({ type: 'add' })}> +1 </button>
    </div>
  );
}

// 第三步，实现 useReducer
let workInProgressFiber = {};
let workInProgressFiber.alternate = {};
let workInProgressFiber.alternate.hooks = [];
let hookIndex = 0;
function useReducer(reducer, initialValue) {
  let nweHook = workInProgressFiber.alternate.hooks[hookIndex];
  if (nweHook) {
    // 第二次进来时，更新hook的值
    newHook.state = newHook.updateQueue.forceUpdate(newHook.state);
  } else {
    // 第一次进来定义一个hook
    newHook = {
      // 传进来的 { count: 0 }
      state: initialValue, 
      // 初始化一个更新队列
      updateQueue: new UpdateQueue(),
    }
  }

  // 这里的action其实就是 {type: "add"}
  // 调用dispatch的时候更新队列，即调用 dispatchCount
  const dispatch = (action) => {
    newHook.updateQueue.enqueueUpdate(
      // 这里的newHook.state 是 {count: 0}。 action 其实就是 {type: "add"}
      // reducer(newHook.state, action)返回的是  { count: state.count + 1};
      new Update(reducer ? reducer(newHook.state, action) : action)
    )
    // 更新完了之后react去更新dom视图
  }
  workInProgressFiber.hooks[hookIndex++] = newHook;

  return [newHook.state, dispatch];
}

// 第四步，实现 Update 
export class Update {
  //  payload: { count: state.count + 1};
  constructor(payload) {
    this.payload = payload;
  }
}

// 第五步，实现 UpdateQueue
export class UpdateQueue {
  constructor() {
    this.firstUpdate = null;
    this.lastUpdate = null;
  }
  // 把上一步的 Update 实例传进来 { count: state.count + 1};
  enqueueUpdate(update) {
    // 如果this.lastUpdate不存在，说明队列还没开始创建，则把update赋值给 头和尾
    if (this.lastUpdate === null) {
      this.firstUpdate = this.lastUpdate = update;
    } 
    // 如果this.lastUpdate尾存在，说明队列已经存在，将update更新事件加到上次队列之后，并把update设置为队列尾
    else {
      this.lastUpdate.nextUpdate = update;
      this.lastUpdate = update;
    }
  }
  // 把初始化的state传进来 state:{count: 0};
  // this.firstUpdate = this.lastUpdate = { count: state.count + 1};
  forceUpdate(state) {
    // 更新队列，从头开始进行更新
    let currentUpdate = this.firstUpdate;
    // currentUpdate存在值，说明队列还没更新完
    while (currentUpdate) {
      let nextState =
        typeof currentUpdate.payload === "function"
          ? currentUpdate.payload(state)
          : currentUpdate.payload;
      state = { ...state, ...nextState };
      currentUpdate = currentUpdate.nextUpdate;
    }
    this.firstUpdate = this.lastUpdate = null;
    return state;
  }
}

```

#### 实现 useState
```javascript
// 没有action,直接使用 initialState，直接使用定义state的 useAction
export function useState(initialState) {
  return useReducer(null, initialState);
}
const [count, useAction] = useState({count: 0});

```



https://juejin.im/post/5ceb36dd51882530be7b1585#heading-10
