- 缓存对象 HTML CSS JS
- 实现方式 HTTP/HTTPS实现
- 存储位置四种
  - Service Worker
  - Memory Cache（内存缓存）
  - Disk Cache（硬盘缓存）
  - Push Cache（推送缓存）
> 以上缓存全部没有命中就会进行网络请求。

### 基础缓存机制

- Service Worker

Service Worker 是运行在浏览器背后的独立线程，可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的 [查看demo](https://github.com/mdn/sw-test)

- Memory Cache

Memory Cache 是`内存中的缓存`，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据高效，但是缓存持续性很短。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。而且由于计算机中的内存比硬盘容量小得多，我们能够使用存储缓存的内存并不多

内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。

- Disk Cache

Disk Cache 是存储在`硬盘中的缓存`，读取速度比 Memory Cache `慢`，但是存储量更`大`。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。

- Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

浏览器什么时候会把缓存存储到内存中，什么时候存储到硬盘中呢？一般来说：

小文件优先存储到内存中，反之存储到硬盘中
使用频率高的缓存到硬盘中


### HTTP 缓存机制

- 强制缓存
> 强制缓存是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求。

设置缓存时间的方法有两种（响应头字段）：

  - Expires （HTTP/1.0）
    ```javascript
    // 告诉浏览器在2020.10.10日之前，可以直接使用该请求的缓存
    {
      Expires: Sat, 10 Oct 2020 00:00:00 GMT
    }
    ```
    存在2个问题
    - 服务端和浏览器的时间可能不同，导致缓存过期时间出现偏差
    - 客户端可以通过修改系统时间来继续使用缓存或提前使缓存失效
    
  - Cache-Control（HTTP/1.1）解决了 Expires 存在的2个问题
    - no-cache：表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新；
    - no-store：禁止浏览器以及所有中间缓存存储响应内容；
    - public：公有缓存，表示可以被代理服务器缓存，可以被多个用户共享；
    - private：私有缓存，不能被代理服务器缓存，不可以被多个用户共享；
    - max-age：以秒为单位的数值，表示缓存的有效时间；
    - must-revalidate：当缓存过期时，需要去服务端校验缓存的有效性。
  
    200 状态码一定是服务器返回的吗？
  > 不是。命中强缓存的话，会直接从内存或者磁盘中读取资源，并返回一个200状态码，具体操作可以试试浏览器的前进后退键。

- 协商缓存
> 协商缓存不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效；否则返回状态码 200 、最新的资源和最新的资源标识。

- Last-Modified：资源的最后修改时间（服务端返回的值）
  1. 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，表示这个资源在服务端上的最近修改时间；
  2. 当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的 Last-Modified，这个请求头叫 If-Modified-Since；
  3. 服务端再次收到请求，根据 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，浏览器使用资源缓存值；否则返回资源内容，且更新 Last-Modified 响应头内容。
  
  这种方法存在3个问题
  1. 精度问题：Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断会失效
  2. 准度问题：如果一个文件被修改后又被还原，内容没有发生变化，却仍然需要重新请求
  3. 服务器问题：某些服务器不能精确的得到文件的最后修改时间

  因此我们需要 ETag

- Etag：资源的唯一标识（一个字符串，hash值）和 If-None-Match

  1. 浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值；
  2. 当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值；
  3. 服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中。

  这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面：
  
  1. 计算成本。对于大文件而言，读取完整的文件内容生成哈希值开销较大；只读取文件部分内容，又容易判断出错。
  2. 计算误差。不同服务端可能会采用不同的哈希值计算方式。所以同一个资源在两台服务端产生的 Etag 可能是不相同的。对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。


两者中会优先使用 Etag：
  - Last-Modified 只能精确到秒级
  - 如果资源被重复生成，而内容不变，Etag 更加精准


### 禁用缓存
- 服务器禁用缓存：
  - Cache-Control: max-age=0, must-revalidate
  - Cache-Control: no-cache
  - Cache-Control: no-store

- 浏览器禁用缓存：
  - 改变 url，加上?xi=xixi
  - 设置请求 header


参考资料

- https://zhuanlan.zhihu.com/p/273651157
- https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers
- https://github.com/mdn/sw-test
