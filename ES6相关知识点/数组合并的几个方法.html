<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
             <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
                         <meta http-equiv="X-UA-Compatible" content="ie=edge">
             <title>Document</title>
</head>
<body>

<script >
var a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
var a2 =['A','B','C','D'];

var a3 = a2.map((item) => {
    return item + 3
  });

// let a4 = [...a1, ...a3].sort().map((item) => {
//     if(item.includes('3')){
//       return item.split('')[0]
//     }
//     return item
//   })

// console.log(a4, '1')

let arr0 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
let arr1 = ['A','B','C','D'];

const handle = (arr0 ,arr1) => {
    let res = arr1.map((item, index) => {
        return [arr0[index*2], arr0[index*2 + 1], item]
    });
    console.log(res, 'res')
    return [].concat(...res)
}
handle(arr0, arr1)

// https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39
// 函数是传递参数的不是传值得
function setName(obj) {
  obj.name = 'laowang';
  console.log(obj, 'obj1')
// 即使在函数内部修改了参数的值，但原始的引用仍然保持未变
  // 实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁
  // ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参 数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而 引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因 为访问变量有按值和按引用两种方式，而参数只能按值传递。
  //    在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。
  obj = new Object();
  obj.name = 'Tom';
  console.log(obj, 'obj2')
  console.log(person, 'person')

}
var person = new Object();
setName(person);
console.log(person.name); // laowang
</script>

</body>
</html>
