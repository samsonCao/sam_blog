### 代码高亮思路

- 使用@babel/code-frames捕获错误
- 使用 console 打印错误
- 使用 @babel/highlight 做语法高亮打印
- 使用 chalk 控制台打印出颜色

### 自动埋点思路

- 如果埋点的内容没有引入，要先引入埋点的内容，通常是函数 `const importModule = require('@babel/helper-module-imports');
`
- 在 `Program`根结点里通过  `path.traverse`来遍历`ImportDeclaration`看是否引入了

- 找到函数节点 `ClassMethod、ArrowFunctionExpression、FunctionExpression、FunctionDeclaration` 插入 `bodyPath.node.body.unshift(state.trackerAST);`

- 并不是所有的函数都需要埋点，可以加注释做标记哪些需要插入

### 自动生成api文档

- 处理 `FunctionDeclaration` 和 `ClassDeclaration`从ast提取信息生成文档
  - FunctionDeclaration：
    - 函数名： path.get('id').toString()
    - 参数： path.get('params')
    - 返回值类型： path.get('returnType').getTypeAnnotation()
    - 注释信息：path.node.leadingComments
    - 注释可以使用 doctrine 来 parse，支持 @xxx 的解析
  ClassDeclaration：
    - 类名：path.get('id').toString()
    - 方法：travese ClassMethod 节点取信息（包括 constructor 和 method）
    - 属性： traverse ClassProperty 节点取信息
    - 注释信息： path.node.leadingComments

- 通过 renderer 拼接成不同的字符串

### linter 静态分析代码，错误捕获， 
> int 其实是 c 语言中的一个工具，在 1979 年由贝尔实验室发布的。它是通过静态分析代码来检查错误的工具。后来各领域的类似工具都叫做 xx lint。比如前端领域的 eslint、styleLint 等

> parse 成 AST，对 AST 进行检查
- 结构错误
  - 代码有逻辑或者语法错误
  - 代码没错误但是不符合代码规范

- 代码格式的错误
  - 代码结构是对的，但是空格、换行等格式不对。

- 检测for循环之类的的代码错误，捕获 ForStatement对各部分因子分析是否符合
- 函数不能重新赋值 `AssignmentExpression`
  - 获取变量的引用需要用 `path.scope.getBinding` 的 api，从作用域中查找 `binding`，然后判断声明的节点是否是一个 `FunctionDeclaration` 或 `FunctionExpression` 。如果是，说明对函数进行了重新赋值，就报错

- 检查出 == 和 === 处理 `BinaryExpression`


### TS的静态类型检查
- 转为AST，然后操作AST获取各种类型，然后就行赋值对比，看定义的类型和赋值的类型是否一致
- 复杂类型，泛型，计算类型，需要先求出真实的类型再对比

### 解析TS的类型描述，生成描述文档
- 获取函数，变量，参数等等类型TS描述，解析AST生成文档

### 压缩混淆
- 名字转换。变量名、函数名这些我们会注意命名要有含义，但是编译后的代码就不需要了，可以把各种 identifier 的 name 重命名为没有含义的 abcd，这个可以通过 path.scope.rename 的 api 来做到
- 逻辑转换。if 的逻辑可以用 switch 来代替，for 的逻辑可以用 while 来代替，这都是等价的，把一种方式实现的代码转成另一种等价的形式就可以达到混淆的目的。做混淆工具主要是要找到这种等价的变化，而且后者一定要特别复杂难以分析，然后实现这种转换，就达到了混淆的目的
- 删除没有使用的语句，通过references 或者 referenced判断是否被引用。

### 模块遍历器，生成模块依赖树
- ImportDeclaration：收集 import 信息，确定依赖的模块和引入的变量，之后再递归处理该模块
- ExportDeclaration：收集 export 信息，确定导出的变量

### 代码转换
- ES next转ES5
- CSS转换
  - CSS预处理编译
  - less scss styles
  - 给css加浏览器前缀
  - 转化为原生CSS
- TypeScript, JSX代码转为JS代码
- Taro等框架
- markdown转html


### LowCode 可视化编码

- 当下LowCode，依旧是前端一大热门领域。目前主流的做法大致下述两种。
  - Schema 驱动。目前主流做法，将表单或者表格的配置，描述为一份 Schema，可视化设计器基于 Schema 驱动，结合拖拽能力，快速搭建。
  - AST 驱动。通过CloudIDE，CodeSandbox等浏览器端在线编译，编码。外加可视化设计器，最终实现可视化编码。
    - 拖拽组件至可设计区域
    - 定位拖拽行为的落点，转化为相应的AST节点位置
    - 更新AST树，并生成最新代码
    - 执行最新代码，更新视图

### code2code
- 以 Vue To React 为例，大致过程跟ES6 => ES5类似，通过vue-template-compiler编译得到Vue AST => 转换为 React AST => 输出 React 代码


- 参考文章
  - https://zhuanlan.zhihu.com/p/486548159?utm_source=wechat_session&utm_medium=social&utm_oi=590620153440505856&utm_campaign=shareopn