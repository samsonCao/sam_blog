#### this是函数内部的一个特殊对象

- this的行为与Java和C#中的this大致类似
- this引用的是函数据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)
- 对象内部方法的this指向调用这些方法的对象
- 在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象
- 多层嵌套的对象，内部方法的this指向离被调用函数最近的对象
- 原型链中的方法的this仍然指向`调用它`的对象
- 构造函数中的this与被创建的新对象绑定。

#### 普通函数中的this
- 在普通函数中的this总是代表它的直接调用者，在默认情况下，this指的是window，
- 在严格模式下,没有直接调用者的函数中的this是undefined使用
- call,apply,bind(ES5新增)绑定的,this指的是绑定的对象

#### 箭头函数中的this
- 箭头函数不绑定this，它会捕获其所在（即定义的位置）上下文的this值，作为自己的this值
```javascript
function Person() {
    this.age = 0;
    setTimeout(() => {
        // 箭头函数不绑定this，此处的this是在Person对象中执行的，
        // 会捕获执行上下文Person中的this，因此指向的是Person对象
        console.log(this);
    }, 3000)
}
var p = new Person();

function Person2() {
    this.age = 0;
    setTimeout(function () {
        // 普通函数绑定this,此时的this指向全局对象Window
        console.log(this)
    }, 3000)
}
var p = new Person2();
```
#### this进阶---引用类型传递的参数函数名FunWindow
> 这个函数名是个指针，执行全局对象window
```javascript
var length = 99;
function FunWindow() {
    console.log(this.length);
}
var Obj = {
  length: 5,
  FunObj: function(fn) {
    // 此处接收的fn就是FunWindow，虽然在Obj对象中定义的，但是此时的FunWindow的this早已和window绑定了，
    // 因此此时执行的this.length指向的是window, 所以var length = 99;
    fn();  // 返回99
    console.log(arguments)

    // arguments[0]是FunWindow，此时的this是arguments，参数2个，长度是2
    arguments[0](); // 返回2，
  }
};

// 此处的FunWindow只是一个变量值，引用指向window下的对象FunWindow函数
Obj.FunObj(FunWindow, 1);
```

#### 构造函数中的this与被创建的新对象绑定
> 函数中的this是在运行是决定的
```javascript
function foo(){
    console.log(this.fruit);
}
// 定义一个全局变量，等同于window.fruit = "banana";
var fruit = "banana";

// 此时函数中的this指向window;
foo();  //   "banana"

var o = {
      fruit : "apple",
      foo : foo // 构造函数foo与对象o绑定因此this是o对象
};
// 此时函数中的this指向o
o.foo();  // "apple"
```
