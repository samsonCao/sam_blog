## this是函数内部的一个特殊对象

- this的行为与Java和C#中的this大致类似
- this引用的是函数据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)
- 对象内部方法的this指向调用这些方法的对象
- 在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象
- 多层嵌套的对象，内部方法的this指向离被调用函数最近的对象
- 原型链中的方法的this仍然指向`调用它`的对象
- 构造函数中的this与被创建的新对象绑定，用到了new，先理解new的创建过程。
- 对象的方法调用，this指向只跟函数调用的对象有关，跟所在的位置无关 对象的方法使用，this指向是与方法最近的对象
- DOM事件处理函数的调用，当函数被当做事件处理函数时，其this指向触发该事件的元素（针对于addEventListener事件）
- setInterval & setTimeout， 属于全局对象的方法，所以this指向的是window
- 在严格模式下,没有直接调用者的函数中的this是undefined使用

#### 在全局作用域和一般的函数中
> this->window
```javascript
console.log(this); // window
function a() {
    console.log(this); // window
}
    a();
```

#### //在方法调用中
> 谁调用this指向谁
```javascript
let obj = {
    name:"zhangsan",
    say:function () {
         console.log(this); //obj
    }
};
obj.say();
```
#### 在构造函数中
- new调用时，this指向构造函数实例
- 不是new调用时，指向执行时的作用域，此处是window
```javascript
function b(name) {
    this.name=name;
    console.log(this);
}
b("lucy");  //this->window
console.log(window.name); // lucy b('lucy')执行后给window增加了name属性，属性值是lucy
let zhangsan = new b("zhangsan"); // new改变this的指向 指向构造函数实例 b {name: "zhangsan"}
```

#### 箭头函数的this
- 箭头函数的this是在`定义时`产生的
- 普通的函数this是在`调用时`产生的
- 箭头函数中没有this，它的this默认使用它父级的this
```javascript
let person={
    name:"wangwu",
    run:()=> {
        //箭头函数中没有this，它的this默认使用它父级的this,
        // 如果父级依然是箭头函数时,他会接着往上找，直到找到为止
        // 此处找到的是window
        console.log(this, 'arrow');
        setTimeout( ()=> {
            console.log(this, 'setTimeout');
        })
    }
};
person.run();
```

#### call/apply，bind
- call,apply,bind(ES5新增)绑定的,this指的是绑定的对象
- this指向括号里的内容
```javascript
let d = {
    x:1,
    fn:function () {
        console.log(this.x);
    }
}
let e = {
    x:2
}
d.fn(); // 1
d.fn.apply(e); // 2
```

#### setInterval & setTimeout中的this
> 属于全局对象的方法，所以this指向的是window
```javascript
// 被调用时，将关联的元素变成蓝色
    function bluify(e){
      //在控制台打印出所点击元素
      console.log(this);
      //阻止时间冒泡
      e.stopPropagation();
      //阻止元素的默认事件
      e.preventDefault();
      this.style.backgroundColor = '#A5D9F3';
    }

    // 获取文档中的所有元素的列表
    var elements = document.getElementsByTagName('*');

    // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
    for(var i=0 ; i<elements.length ; i++){
      elements[i].addEventListener('click', bluify, false);
    }
```

#### DOM事件处理函数的调用
> 当函数被当做事件处理函数时，其this指向触发该事件的元素（针对于addEventListener事件）
```javascript
// 被调用时，将关联的元素变成蓝色
function bluify(e){
  //在控制台打印出所点击元素
  console.log(this);
  //阻止时间冒泡
  e.stopPropagation();
  //阻止元素的默认事件
  e.preventDefault();
  this.style.backgroundColor = '#A5D9F3';
}

// 获取文档中的所有元素的列表
var elements = document.getElementsByTagName('*');

// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
for(var i=0 ; i<elements.length ; i++){
  elements[i].addEventListener('click', bluify, false);
}
```

------

#### this进阶---箭头函数和setTimeout中的this
- 箭头函数不绑定this，它会捕获其所在（即定义的位置）上下文的this值，作为自己的this值
```javascript
function Person() {
    this.age = 0;
    setTimeout(() => {
        // 箭头函数不绑定this，此处的this是在Person对象中执行的，
        // 会捕获执行上下文Person中的this，因此指向的是Person对象
        console.log(this);
    }, 3000)
}
var p = new Person();

function Person2() {
    this.age = 0;
    setTimeout(function () {
        // 普通函数绑定this,此时的this指向全局对象Window
        console.log(this)
    }, 3000)
}
var p = new Person2();
```
#### this进阶---引用类型传递的参数函数名FunWindow
> 这个函数名是个指针，执行全局对象window
```javascript
var length = 99;
function FunWindow() {
    console.log(this, '888')
    console.log(this.length);
}
var Obj = {
  length: 5,
  FunObj: function(fn) {
    // 此处接收的fn就是FunWindow，虽然在Obj对象中定义的，但是此时的FunWindow的this早已和window绑定了，
    // 因此此时执行的this.length指向的是window, 所以var length = 99;
    fn();  // 返回99

    //下面两个相等和全等都是true,说明是同一个引用类型的地址
    console.log(fn == arguments[0], fn === arguments[0])

    // arguments[0]是FunWindow
    // this是在arguments对象的作用于中执行的，此时的this是arguments，函数参数2个，长度是2
    // 通过对象内部的属性访问一个方法时，方法内部的this会指向该对象。所以
    arguments[0](); // 返回2，
  }
};

// 此处的FunWindow只是一个变量值，引用指向window下的对象FunWindow函数
Obj.FunObj(FunWindow, 1);
```
