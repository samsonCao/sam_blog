<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //在全局作用域和一般的函数中  this->window
    console.log(this); // window
    function a() {
        console.log(this); // window
    }
    a();
    //在方法调用中，谁调用this指向谁
    let obj = {
        name:"zhangsan",
        say:function () {
            console.log(this); //obj
        }
    };
    obj.say();




    //箭头函数的this是在定义时产生的，普通的函数this是在调用时产生的
    let person={
        name:"wangwu",
        run:()=> {
            //箭头函数中没有this，它的this默认使用它父级的this,
            // 如果父级依然是箭头函数时,他会接着往上找，直到找到为止
            // 此处找到的是window
            console.log(this, 'arrow');
            setTimeout( ()=> {
                console.log(this, 'setTimeout');
            })
        }
    };
    person.run();
    //

    //call/apply this指向括号里的内容
    let d = {
        x:1,
        fn:function () {
            console.log(this.x);
        }
    }
    let e = {
        x:2
    }
    d.fn();
    d.fn.apply(e);


    // 通过对象的方法进行调用,
    // 结论：通过对象内部的属性访问一个方法时，方法内部的this会指向该对象。
    var source = 'I come from window'
      function fn () {
        console.log(this.source)
      }
      var obj = {
        source: 'I come from obj',
        fn: fn
      }
      fn() // I come from window
      obj.fn() // I come from obj
</script>
