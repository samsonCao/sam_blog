#### 此文必定是超级长文，里面的方法会逐个实现，敬请期待......


### 1.call模拟实现

1. call语法
```javascript
fun.call(thisArg, arg1, arg2, ...)
```

2. call含义

call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法然后执行该方法。

3. call体验
```javascript
var person = {
    name: 'sam',
    eat: function(){
        console.log('eating!');
        console.log(this.name);
        return 'eat';
    }
};

var another = {
	name: 'tom',
	drink: function(){
		console.log('drinking!');
		console.log(this.name);
		return 'drink'
	}
};

// eat函数在another的作用域中执行
// 因此返回eating, this.name指向的是another的name/tom
person.eat.call(another, '99', '88', '77'); // eating/tom/eat
```

4. call模拟实现
```javascript
/**
* A.myCall(B) 做两件事
* 1.把A放在B的作用于中执行
* 2.并返回A的返回值
* 3.myCall可以接收多个参数，以逗号分隔
* 相当于作用于B劫持了函数A，获取了A的方法
* @param context
* @returns {any}
*/
Function.prototype.myCall = function (context) {

    // context是第一个参数，call中传入的对象即another
    // 让函数在这个对象中执行
    // 不传是window
    var callObj = context || window;

    // 新增属性fn, 让this指向这个fn
    // 此处执行的函数是eat,this就是指eat函数
    console.log(this, 'this');

    // 把eat函数放在callObj即another作用域中
    // 注意: 这里传递的只是eat函数的引用地址
    callObj.fn = this;

    var args = [];

    // 获取call中除了第一个参数的其它参数
    for(var i = 1, len = arguments.length; i < len; i++) {
        // 此处push的是arguments[i]的引用而不是arguments对应的值
        // 如果是push,arguments[i]就是把值放进去
        args.push('arguments[' + i + ']');
    }
    console.log(args); //["arguments[1]", "arguments[2]", "arguments[3]"]
    // 把数组参数拼接成字符串参数逗号分隔
    // 注意: 数组和字符串拼接会去掉数组的[], 例子: '3' + [1, 2] ==> "31,2"
    var str = 'callObj.fn(' + args +')';
    console.log(str); //callObj.fn(arguments[1],arguments[2],arguments[3])

    // 把要执行的函数eat放在another的作用于中执行
    // 把函数和参数转为字符串在eval中执行，如果有返回值就返回result
    var result = eval('callObj.fn(' + args +')');
    console.log(result); // eat

    // 删除在context参数上添加的属性fn
    delete callObj.fn;
    return result;
};

var person = {
    name: 'sam',
    eat: function(){
        console.log('eating!');
        console.log(this.name);
        return 'eat';
    }
};

var another = {
	name: 'tom',
	drink: function(){
		console.log('drinking!');
		console.log(this.name);
		return 'drink'
	}
};

// eat函数在another的作用域中执行
// 因此返回eating, this.name指向的是another的name/tom
person.eat.myCall(another, '99', '88', '77'); // eating/tom/eat
```

### 2.apply模拟实现


1. apply语法
```javascript
func.apply(thisArg, [argsArray])
```

2. apply含义

apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。

3. apply体验
```javascript
var numbers = [5, 6, 2, 3, 7];
var min = Math.min.apply(null, numbers);

// 获取数组最小值
console.log(min); // 2
```

4. apply模拟实现
```javascript
/**
* A.myCall(B, []) 做两件事
* 1.把A放在B的作用于中执行
* 2.并返回A的返回值
* 3.myApply可以接收2参数，第二个参数是数组
* 相当于作用于B劫持了函数A，获取了A的方法
* @param context
* @returns {any}
*/
Function.prototype.myApply = function (context, arr) {
	var applyObj = context || window;
	var result;
	applyObj.fn = this;
	if (!arr) { // 如果没有传入数组参数，则直接调用ctx.fn方法
		result = applyObj.fn()
	} else {
	    var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
	    result = eval('applyObj.fn(' + args +')');
	}
	delete applyObj.fn;
	return result
};

var person = {
    name: 'sam',
    eat: function(args){
        console.log('eating!');
        console.log(this.name);
        return 'eat';
    }
};

var another = {
	name: 'tom',
	drink: function(){
		console.log('drinking!');
		console.log(this.name);
		return 'drink'
	}
};

person.eat.myApply(another, ['999', '888', 4]);
```
apply巧妙用例

1. 获取一个数组的最大值
```javascript
// apply内部会把array数组转为参数列表在max函数的作用域内执行
var max=Math.max.apply(null,array)
```

2. 数组合并
```javascript
var array = ['a', 'b'];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

`注意：call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。`

重要参考：https://www.zhihu.com/question/35787390

### 3.bind模拟实现

1. bind语法
```javascript
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

2. bind含义

bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。

3. bind体验
```javascript
var module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

var unboundGetX = module.getX;
// window下面是没有x属性的，因此unboundGetX在window执行上下文执行时输出undefined
console.log(unboundGetX()); // undefined

// 让unboundGetX在module的作用域下执行，this.x就是module作用域下的x=> 42
var boundGetX = unboundGetX.bind(module);
console.log(boundGetX()); // 42
```

4. bind模拟实现
```javascript
var module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

Function.prototype.myBind = function (context) {
    // 此处的context是module对象

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    // 此处的this是getX函数
    var self = this;
    // 去掉第一个参数thisArg之后的剩余参数,组成一个数组[arg2,arg3,arg4....]
    var args = Array.prototype.slice.call(arguments, 1);

    // 函数声明的方式创建一个函数，
    var samFunc = function () {};

    var samBound = function () {
        /**
        * 此处的this是samBound执行上下文中的this,self是myBind执行作用域中的this
        *
        * 1.当作为构造函数(new出来有自己的作用域)时，this指向实例samBound{}，
          self指向绑定函数module.getX{},

        * 2.当作为普通函数时，this 指向 window,因为samBound最终是在window的作用域下执行的，
          self指向绑定函数module.getX{}，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
        */

        // instanceof判断一个实例this是否属于某种类型self
        console.log(this, 'samBound-this')
        console.log(self, 'samBound-self')
        console.log(this instanceof self, 'istrue');
        console.log(context, 'context')

        // 返回绑定函数执行的结果
        return self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
    }

    /**
    * 下面这段代码是精华
    * 使用了原型模式继承用
    * 把绑定函数this的prototype赋值给声明函数samFunc的prototype，
    * 实例new samFunc()可以继承samFunc.prototype中的值
    * 也就是继承self.prototype中的值
    * 也就是继承getX中的值
    */
    samFunc.prototype = self.prototype;
    samBound.prototype = new samFunc();
    /**
    * samBound的prototype指向了samFunc的实例，继承了samFunc的prototype中的方法
    * samFunc的prototype指向了self.prototype，继承了self.prototype的方法，而self就是执行时的getX
    * 通过new samFunc把self和samBound关联起来，同时又不至于共享prototype的属性和方法
    */

    /**
    * 两行代码合成一行会出问题
    * samBound.prototype = self.prototype;
    */

    // 返回构造函数bind
    return samBound;

}

var boundGetX = module.getX.myBind(module, '1', '2');
console.log(boundGetX()); // 42

/**
* samFunc.prototype = self.prototype;
* samBound.prototype = new samFunc();
* 两行代码合成一行会出问题
* samBound.prototype = self.prototype;
*/
// boundGetX.prototype.value = '1';
// console.log(module.getX.prototype.value) // '1'
```
`注意bind和call、apply不同的是返回值是个新函数，并没有执行`

参考： https://github.com/mqyqingfeng/Blog/issues/12


### 4.new操作符模拟实现

1. 含义

执行某个声明的函数，并返回这个函数的一个实例

2. 语法
```javascript
new constructor[([arguments])]
```

3. 体验
```javascript
function Car(make, model, year) {
   this.make = make;
   this.model = model;
   this.year = year;
}
var mycar = new Car("Eagle", "Talon TSi", 1993);
console.log(mycar); //Car {make: "Eagle", model: "Talon TSi", year: 1993}
```

new 操作符的内部执行过程基本过程

1.创建一个新的空对象。

2.将构造函数的作用域赋给新对象（即this指向它）。

3.新对象增加构造函数的基本方法和属性。

4.返回新对象
 ```javascript
function Person(name,age){
　　this.name = name;
　　this.age = age;
}
function myNew(){
    //1.拿到传入的参数中的第一个参数，即构造函数名Func
    var Func = [].shift.call(arguments);
    console.log(Func)
    if (typeof Func !== "function") {
          throw new Error("myNew argument[0] - what is trying to be bound is not callable");
    }
    //2.创建一个空对象obj
    var obj = {};

    /**
    * 3.将这个空对象的__proto__成员指向了Func构造函数prototype成员对象
    * js里所有的对象都有proto属性(对象，函数)，指向构造该对象的构造函数的原型。
    * obj.__proto__初始化时指向Object,手动修改指向构造函数，此处示例的是Person
    **/
    obj.__proto__= Func.prototype;

    //4.当myNew执行时，在obj对象中执行构造函数Func
    Func.apply(obj,arguments);

    //5.返回创建的对象obj,这个返回的obj就是构造函数的实例
    return obj
}
var person = myNew(Person,'xiaoming',18)
console.log(person, 'person') //{name: "xiaoming", age: 18}
```

> 注意：返回的是新对象

```javascript
var a = new String('123')
var b = new String('123')
console.log( a == b ) // false

// 因为new关键词创造的a和b变量都是对象，是引用类型，各自创建了自己的堆内存
// 因此a 和 b的指向完全不是同一个地址，当然不相等
```

### 5.instanceof的模拟实现
1. instanceof语法
```javascript
object instanceof constructor
```

2. instanceof含义

`instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。`

instanceof运算符用于测试构造函数的prototype属性是否出现在对象的`原型链中的任何位置`

3. instanceof体验
```javascript
// 定义构造函数
function A(){};

var o = new A();

// o 是 A的实例
// Object.getPrototypeOf(o) === A.prototype
o instanceof A; // true

// 参数o的原型链上有Object.prototype,因为A也是Object的实例
// Object.prototype.isPrototypeOf(o)返回true
o instanceof Object; // true

A.prototype instanceof Object // true,同上

/**
*
* 更改A.prototype指向一个空对象
* 实例化此时的A
*/
A.prototype = {};
var o2 = new A();

o2 instanceof A; // true

// A.prototype指向了一个空对象,这个空对象不在o的原型链上.
o instanceof A; // false
```

4. instanceof模拟实现
```javascript
function instance_of(left, right) {
    // 取右表达式的 prototype 值
    let rightProto = right.prototype;

    // 取左表达式的__proto__值
    left = left.__proto__;
    while (true) {
    	if (left === null) {
            return false;
        }
        if (left === rightProto) {
            return true;
        }

        // 上面两个条件都不满足时，找上级的__proto__，一直往上找，直到找到null
        left = left.__proto__
    }
}

```

`如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，
因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，
这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，
就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，
但借助于非标准的__proto__伪属性，是可以实现的。
比如执行obj.__proto__ = {}之后，obj instanceof Foo就会返回false了。`

参考：https://juejin.im/post/5b0b9b9051882515773ae714

### 6. JSON.stringify/JSON.parse模拟实现
1. 语法
```javascript
JSON.stringify(value[, replacer[, space]])
JSON.parse(text[, reviver])
```
- [JSON.stringify具体API参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
- [JSON.parse具体API参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)

2. JSON.stringify含义

是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，
如果指定了replacer是一个函数，则可以替换值，或者如果指定了replacer是一个数组，可选的仅包括指定的属性。

3. JSON.stringify体验
```javascript
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1,"false",false]'
JSON.stringify({ x: 5 });
JSON.stringify({x: undefined, y: Object, z: Symbol("")}); // '{}'
JSON.stringify([undefined, Object, Symbol("")]);          // '[null,null,null]'
JSON.stringify({[Symbol("foo")]: "foo"});                 // '{}'
JSON.stringify({[Symbol.for("foo")]: "foo"}, [Symbol.for("foo")]); // '{}'
```

4. JSON.parse体验
```javascript
JSON.parse('{}');              // {}
JSON.parse('true');            // true
JSON.parse('"foo"');           // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse('null');            // null
JSON.parse('1');               //  1
JSON.parse('{"p": 5}', function (k, v) {
    if(k === '') return v;     // 如果到了最顶层，则直接返回属性值，
    return v * 2;              // 否则将属性值变为原来的 2 倍。
});                            // { p: 10 }

```

5. JSON.stringify/JSON.parse模拟实现
```javascript
if (!window.JSON) {
  window.JSON = {
    parse: function(sJSON) { return eval('(' + sJSON + ')'); },
    stringify: (function () {
      var toString = Object.prototype.toString;
      var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
      var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
      var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
      var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
      return function stringify(value) {
        if (value == null) {
          return 'null';
        } else if (typeof value === 'number') {
          return isFinite(value) ? value.toString() : 'null';
        } else if (typeof value === 'boolean') {
          return value.toString();
        } else if (typeof value === 'object') {
          if (typeof value.toJSON === 'function') {
            return stringify(value.toJSON());
          } else if (isArray(value)) {
            var res = '[';
            for (var i = 0; i < value.length; i++)
              res += (i ? ', ' : '') + stringify(value[i]);
            return res + ']';
          } else if (toString.call(value) === '[object Object]') {
            var tmp = [];
            for (var k in value) {
              if (value.hasOwnProperty(k))
                tmp.push(stringify(k) + ': ' + stringify(value[k]));
            }
            return '{' + tmp.join(', ') + '}';
          }
        }
        return '"' + value.toString().replace(escRE, escFunc) + '"';
      };
    })()
  };
}
```
重要参考：

1. https://github.com/douglascrockford/JSON-js
2. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON
3. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse

### 7. 使用setTimeout实现setInterval
1. 语法
```javascript
var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...]);
var timeoutID = scope.setTimeout(function[, delay]);
var timeoutID = scope.setTimeout(code[, delay]);
```
参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout


```javascript
let intervalID = window.setInterval(func, delay[, param1, param2, ...]);
let intervalID = window.setInterval(code, delay);
```
参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval

2. 概念

    2.1 设定一个定时器，在定时器到期时执行一个函数

    2.2 WindowOrWorkerGlobalScope 的 setInterval() 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。

3. 缺点
https://segmentfault.com/a/1190000013702430
https://www.jianshu.com/p/fc9a08ca2c92
4. 实现
```javascript
var timer = setTimeout(function() {
   执行内容....
    timer = setTimeout(arguments.callee, 2000)//再次调用
  }, 2000)
```
> 在严格模式下，第5版 ECMAScript (ES5) 禁止使用 arguments.callee()。当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明.
5. 好处
- 在前一个定时器执行完前，不会向队列插入新的定时器（解决缺点一）
- 保证定时器间隔（解决缺点二）

### 8.class构造以及集成的模拟实现

请使用
[babel在线转码工具](https://babeljs.io/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAEqRB5ARgK2gbwFDR74B7AOwgBcAnAV2BPzIAoAPAGgE8BKLXL6EgCwEsIAOgbQAvNAYBubNxx9BQluOgsZcgL6yuZAKaEAJrvodt3AsXwhdQkPgDmdAOQQwAWydszOLVw1A&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.4.4&externalPlugins=)
查看转码后的代码

- class实现原理
- constructor实现原理
- extend实现原理
- super实现原理

#### class实例包含class、extends、constructor、super、static五个关键词
```javascript
// _classCallCheck
// 一个class就是通过创建并执行一个匿名函数，在这个匿名函数中声明function Parent,最后返回Parent。
class Parent {
    constructor(a, b) {
      // Parent函数内的a,b是参数
      // 单纯的this.field1 = a;
        this.filed1 = a;

      // 单纯的const
        const aaa = 999;
    }

    // _defineProperty
    filed2 = 2;

	//_defineProperty
    func1 = function() {};

	//_createClass(Parent, [{}]
    render() {
        return 9;
    };
    thiscall() {
      console.log(b)
        return 8;
    };
    static fn(){
        console.log('static')
    }
}

//_inherits(Child, _Parent);
class Child extends Parent {
	//  function Child(a, b) {}
    constructor(a, b) {
      //_this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, a));
        super(a);

        this.filed3 = b;
    }
  // _classCallCheck(this, Child)


  //_defineProperty
    filed4 = 1;

// _defineProperty
    func2 = function() {}
}

```

#### 经过babel编译过的代码
```javascript
"use strict";

// 回调判断obj是symbol类型还是其他类型
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    }
    return _typeof(obj);
}

// super实现原理
// object类型和function类型返回call, 其它类型如果有super返回自身
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}

// 寻找对象原型,读取一个对象的 prototype 对象
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

// 检测是否调用super
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}

// extends实现原理
// 子类的prototype增加constructor属性指向一个对象,
// 可以看出extend背后是通过js的原型链实现的。
// 其中在class b extends a中要将a传入b中。
function _inherits(subClass, superClass) {
    // 检测父类是否可继承，确保superClass为function
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
     // subClass.prototype的[[prototype]]关联到superClass superClass.prototype
     // 使子类继承父类的属性，并且将constructor指向子类的构造函数
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
     // 设置subclass的内置[[prototype]]与superClass相关联
    if (superClass) _setPrototypeOf(subClass, superClass);
}

// 子类的__proto__指向父类构造函数
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}

// 检测左边的是右边的实例，说明是new出来的
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}

//类型检测，检测对象是否是new出来的
function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

// 给对象添加属性
function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor);
    }
}

// class实现原理
// 创建类基本属性和静态属性此处是Parent添加方法render...
// function _createClass(目标对象, 共有方法数组, 私有方法数组) {}
function _createClass(Constructor, protoProps, staticProps) {
    // 共有方法prototype原型对象上
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);

    // 私有方法写在了类上只有通过类才可以调用，实例化对象无法调用
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

// 设置属性
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
        obj[key] = value;
    }
    return obj;
}

// _classCallCheck
var Parent =
/*#__PURE__*/
function () {
  function Parent(a, b) {
    _classCallCheck(this, Parent);

    _defineProperty(this, "filed2", 2);

    _defineProperty(this, "func1", function () {});

    // Parent函数内的a,b是参数
    // 单纯的this.field1 = a;
    this.filed1 = a; // 单纯的const

    var aaa = 999;
  } // _defineProperty

  //_createClass(Parent, [{}]
  _createClass(Parent, [{
    key: "render",
    value: function render() {
      return 9;
    }
  }, {
    key: "thiscall",
    value: function thiscall() {
      console.log(b);
      return 8;
    }
  }],[
    {
     key: "fn",
     value: function fn() {
        console.log('static');
     }
    }]
   );

  return Parent;
}(); //_inherits(Child, _Parent);


var Child =
/*#__PURE__*/
function (_Parent) {
  _inherits(Child, _Parent);

  //  function Child(a, b) {}
  // constructor实现原理
  function Child(a, b) {
    var _this;

    _classCallCheck(this, Child);

    //_this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, a));
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, a));

    _defineProperty(_assertThisInitialized(_this), "filed4", 1);

    _defineProperty(_assertThisInitialized(_this), "func2", function () {});

    _this.filed3 = b;
    return _this;
  } // _classCallCheck(this, Child)
  //_defineProperty


  return Child;
}(Parent);
```


### 9. Set模拟实现

https://blog.csdn.net/tian_123456789/article/details/89400461

https://www.jianshu.com/p/1eb3784bd6d9

https://www.baidu.com/s?wd=js%20Set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0&rsv_spt=1&rsv_iqid=0xc550f116000011d8&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&oq=Set%25E6%25A8%25A1%25E6%258B%259F%25E5%25AE%259E%25E7%258E%25B0&rsv_t=8275xcKlSegUzUpfXGSHo0iglCkmPUxR7pDrQHsWrarkSNv2IJpoLOHYaS8TkUY3Uy6b&inputT=822&rsv_pq=aa364bac00050ea4&rsv_sug3=31&rsv_sug2=0&rsv_sug4=1555

Promise模拟实现

async/await模拟实现

Symbol模拟实现

深拷贝模拟实现

树形结构数组改为一级结构模拟实现

函数防抖实现

函数节流实现

使用Promise实现串行






